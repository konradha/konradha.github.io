<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>א</title><link>https://konradha.github.io/</link><description>Recent content on א</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 11 Mar 2024 11:19:54 +0100</lastBuildDate><atom:link href="https://konradha.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>T=0 in a glassy system = ?</title><link>https://konradha.github.io/posts/iterated-csps/</link><pubDate>Mon, 11 Mar 2024 11:19:54 +0100</pubDate><guid>https://konradha.github.io/posts/iterated-csps/</guid><description>I&amp;rsquo;ve been researching a lattice-based glassy system. The authors of this work explain a little how we find the ground state in the Hamiltonian
$$H = \sum_{i \in L^k} n_i \left(\sum_{j \in \partial i} n_j - l_i\right)^2$$
at T=0 and k=3 with periodic boundary conditions. The terms n and l denote site occupation and how many particles are ideal per particle type, respectively. We have no external field. It assumes a fixed particle density ϱ with two types of particles, each with different (fixed) density.</description></item><item><title>Sliced traversals</title><link>https://konradha.github.io/posts/sliced_traversal/</link><pubDate>Tue, 16 Jan 2024 14:43:25 +0100</pubDate><guid>https://konradha.github.io/posts/sliced_traversal/</guid><description>Writing Monte Carlo simulation can be a fiddly task. For one, it&amp;rsquo;s sometimes hard to follow parametrizations mentioned (not explained) in existing literature. Sometimes, your simulation is just not saturating the right statistic.
Another thing is getting your code to run quickly to jump across orders of magnitudes of domain sweeps. Depending on your algorithmic formulation you&amp;rsquo;re allowed to do sequential trials. Sometimes you may divide your domain into subdomains which exchange halos and thus you can parallelize nicely.</description></item><item><title>Affinity</title><link>https://konradha.github.io/posts/affinity/</link><pubDate>Wed, 03 Jan 2024 17:49:50 +0100</pubDate><guid>https://konradha.github.io/posts/affinity/</guid><description>You have some nested loop and you found a strategy to parallelize it. You don&amp;rsquo;t introduce false sharing, race conditions, anything you don&amp;rsquo;t want. It looks somewhat like this when using OpenMP:
# pragma omp parallel for // collapse, ... for (size_t i = 0; i &amp;lt; nx; i += kx) // do work Do you let your OS or your OpenMP implementation decide where these threads are sitting?
Luckily, there are several tools that can help you explore these choices.</description></item><item><title>Solving PDEs using ✨Machine Learning✨</title><link>https://konradha.github.io/posts/pinns/</link><pubDate>Wed, 07 Jun 2023 18:57:35 +0200</pubDate><guid>https://konradha.github.io/posts/pinns/</guid><description>At university some of us choose to learn how to solve PDEs numerically. Usually, you pass years learning about approximation theory, test functions, finite elements, C++, functional analysis, visualization libraries, parallelization. Finally, you put it together to solve heat or wave equations. Then, when you&amp;rsquo;re more of a practitioner in industry, you fall back to using Ansys. In 2023 however, we can just take our good ol&amp;rsquo; reliable Pytorch and have Adam walk the space that minimizes the residuals we define for a given PDE.</description></item><item><title>Minimum weight error correction in the surface code</title><link>https://konradha.github.io/posts/surface_code_note/</link><pubDate>Fri, 12 May 2023 15:38:47 +0200</pubDate><guid>https://konradha.github.io/posts/surface_code_note/</guid><description>I&amp;rsquo;ve gotten a little confused by different terminologies and complexities involved in correcting errors in the surface code so I&amp;rsquo;ve rewritten the MWPM-involving algorithm to better understand it. A good reference (with fast accompanying library) is 1.
Picture the surface code. Consider the following procedure to estimate and correct the error in a given word.
Generate the parity check matrix H for one of the operators (X-type or Z-type) over mod 2.</description></item><item><title>Hello World</title><link>https://konradha.github.io/posts/hello-world/</link><pubDate>Sun, 09 Oct 2022 15:47:02 +0200</pubDate><guid>https://konradha.github.io/posts/hello-world/</guid><description/></item><item><title>About</title><link>https://konradha.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://konradha.github.io/about/</guid><description>I&amp;rsquo;m Konrad. I write on niche things of interest to me. Come say hi at konradha email_symbol yahoo.com.</description></item></channel></rss>