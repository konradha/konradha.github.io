<!doctype html><html class="not-ready text-sm lg:text-base" style=--bg:#f8f5d7 lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Sliced traversals - א</title>
<meta name=theme-color><meta name=description content="Writing Monte Carlo simulation can be a fiddly task. For one, it&rsquo;s sometimes hard to follow parametrizations mentioned (not explained) in existing literature. Sometimes, your simulation is just not saturating the right statistic.
Another thing is getting your code to run quickly to jump across orders of magnitudes of domain sweeps. Depending on your algorithmic formulation you&rsquo;re allowed to do sequential trials. Sometimes you may divide your domain into subdomains which exchange halos and thus you can parallelize nicely."><meta name=author content="א"><link rel="preload stylesheet" as=style href=https://konradha.github.io/main.min.css><script defer src=https://konradha.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=preload as=image href=https://konradha.github.io/theme.png><link rel=preload as=image href=https://konradha.github.io/twitter.svg><link rel=preload as=image href=https://konradha.github.io/github.svg><link rel=icon href=https://konradha.github.io/favicon.ico><link rel=apple-touch-icon href=https://konradha.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.121.2"><meta property="og:title" content="Sliced traversals"><meta property="og:description" content="Writing Monte Carlo simulation can be a fiddly task. For one, it&rsquo;s sometimes hard to follow parametrizations mentioned (not explained) in existing literature. Sometimes, your simulation is just not saturating the right statistic.
Another thing is getting your code to run quickly to jump across orders of magnitudes of domain sweeps. Depending on your algorithmic formulation you&rsquo;re allowed to do sequential trials. Sometimes you may divide your domain into subdomains which exchange halos and thus you can parallelize nicely."><meta property="og:type" content="article"><meta property="og:url" content="https://konradha.github.io/posts/sliced_traversal/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-16T14:43:25+01:00"><meta property="article:modified_time" content="2024-01-16T14:43:25+01:00"><meta itemprop=name content="Sliced traversals"><meta itemprop=description content="Writing Monte Carlo simulation can be a fiddly task. For one, it&rsquo;s sometimes hard to follow parametrizations mentioned (not explained) in existing literature. Sometimes, your simulation is just not saturating the right statistic.
Another thing is getting your code to run quickly to jump across orders of magnitudes of domain sweeps. Depending on your algorithmic formulation you&rsquo;re allowed to do sequential trials. Sometimes you may divide your domain into subdomains which exchange halos and thus you can parallelize nicely."><meta itemprop=datePublished content="2024-01-16T14:43:25+01:00"><meta itemprop=dateModified content="2024-01-16T14:43:25+01:00"><meta itemprop=wordCount content="436"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Sliced traversals"><meta name=twitter:description content="Writing Monte Carlo simulation can be a fiddly task. For one, it&rsquo;s sometimes hard to follow parametrizations mentioned (not explained) in existing literature. Sometimes, your simulation is just not saturating the right statistic.
Another thing is getting your code to run quickly to jump across orders of magnitudes of domain sweeps. Depending on your algorithmic formulation you&rsquo;re allowed to do sequential trials. Sometimes you may divide your domain into subdomains which exchange halos and thus you can parallelize nicely."></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://konradha.github.io/>א</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#f8f5d7".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/konradha_ target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/konradha target=_blank rel=me>github</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pb-24 pt-16 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">Sliced traversals</h1><div class="text-sm opacity-60"><time>Jan 16, 2024</time></div></header><section><p>Writing Monte Carlo simulation can be a fiddly task. For one,
it&rsquo;s sometimes hard to follow parametrizations mentioned (not explained)
in existing literature. Sometimes, your simulation is just not saturating
the right statistic.</p><p>Another thing is getting your code to run quickly to jump across orders
of magnitudes of domain sweeps. Depending on your algorithmic formulation you&rsquo;re
allowed to do sequential trials. Sometimes you may divide your domain into
subdomains which exchange halos and thus you can parallelize nicely.
Some people spend a long time trying to come up with with patterns that let
your architecture perform sweeps in an embarrassingly parallel setting.</p><p>The Hamiltonian I&rsquo;m currently looking at is defined on a cubic lattice.
Every term is local in that it only depends on its nearest neighbors.
Translating this into a Monte Carlo formulation already poses the problem
of having rather large radii for each trial move you propose: Threads
running on the same grid will need to be at least 4 steps apart (in each dimension)
or else you&rsquo;re introducing a race condition.</p><p>Here&rsquo;s a tedious but I&rsquo;d say somewhat safe way to go about parallelizing across
the grid: Assume your grid has dimensions L x L x L: Fix indices i + t * 4 for each
thread t. Then, each thread can comfortably traverse its own 2d slice of the grid in
parallel to all other threads t&rsquo;. Unfortunately, this implies you would have to
do this 4 times (modulo L). Hence you would need to introduce about 4 barriers
for each sweep you take. You want to minimize waits and thread spawns, so running
the parallelization in an already parallel region with well-defined parameters
should do the trick.</p><p>As an illustration, consider the following pythonic grid:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>L <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>N <span style=color:#f92672>=</span> L <span style=color:#f92672>*</span> L <span style=color:#f92672>*</span> L
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>arange(<span style=color:#ae81ff>0</span>, L) 
</span></span><span style=display:flex><span>y <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>arange(<span style=color:#ae81ff>0</span>, L)
</span></span><span style=display:flex><span>xx, yy <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>meshgrid(x, y)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>hlines(y, <span style=color:#ae81ff>0</span>, L, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;k&#39;</span>, alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>.2</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>vlines(x, <span style=color:#ae81ff>0</span>, L, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;k&#39;</span>, alpha<span style=color:#f92672>=</span><span style=color:#ae81ff>.2</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>scatter(xx, yy, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;w&#39;</span>, marker<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;s&#39;</span>, s<span style=color:#f92672>=</span><span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>colors <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;red&#34;</span>, <span style=color:#e6db74>&#34;green&#34;</span>, <span style=color:#e6db74>&#34;blue&#34;</span>, <span style=color:#e6db74>&#34;pink&#34;</span>]
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> s <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>4</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> t <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>4</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(s, L, <span style=color:#ae81ff>4</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(t, L, <span style=color:#ae81ff>4</span>):
</span></span><span style=display:flex><span>                plt<span style=color:#f92672>.</span>scatter(xx[i, j], yy[i, j], color<span style=color:#f92672>=</span>colors[t])
</span></span></code></pre></div><p>We create a grid and color the slices which we can process in parallel with the same
colors:</p><img src=/sliced.png><p>Accessing the nearest neighbors will be done like so.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>nn</span>(i, j, L):
</span></span><span style=display:flex><span>    l, r <span style=color:#f92672>=</span> (i, (j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> L), (i, (j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> L)
</span></span><span style=display:flex><span>    u, d <span style=color:#f92672>=</span> ((i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> L, j), ((i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> L, j)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> l, r, u, d
</span></span></code></pre></div><p>Maybe I&rsquo;ll expand this with a more illustrative Jupyter notebook.</p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://konradha.github.io/posts/affinity/><span>Affinity</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href=https://konradha.github.io/>א</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Theme Paper</a></footer></body></html>