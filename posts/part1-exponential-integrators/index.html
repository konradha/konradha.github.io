<!doctype html><html class="not-ready lg:text-base" style=--bg:#f8f5d7 lang=en dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Exponential Integrators for PDEs - א</title><meta name=theme-color><meta name=description content="Disclaimer: Lots of sources are missing here. Will be added in the future.
This is the first one of a sequence of posts during which we&rsquo;ll work through
efficiently writing a simple finite differences simulation. We&rsquo;ll touch on some physics,
some numerical methods, some C++, some CUDA. Eventually we&rsquo;ll see some pretty animations.
Integrable Systems
Understanding nature is hard. For instance, the Millenium prize to find analytical solutions
to the Navier-Stokes equation is still up for grabs. Fermion systems scale exponentially
in the number of particles in a system. Lots of systems do not give us easy access to
analytical or even numerical solutions we can be sure are correct."><meta name=author content="א"><link rel="preload stylesheet" as=style href=https://konradha.com/main.min.css><link rel=preload as=image href=https://konradha.com/theme.png><script defer src=https://konradha.com/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://konradha.com/favicon.ico><link rel=apple-touch-icon href=https://konradha.com/apple-touch-icon.png><meta name=generator content="Hugo 0.147.6"><meta itemprop=name content="Exponential Integrators for PDEs"><meta itemprop=description content="Disclaimer: Lots of sources are missing here. Will be added in the future.
This is the first one of a sequence of posts during which we’ll work through efficiently writing a simple finite differences simulation. We’ll touch on some physics, some numerical methods, some C++, some CUDA. Eventually we’ll see some pretty animations.
Integrable Systems Understanding nature is hard. For instance, the Millenium prize to find analytical solutions to the Navier-Stokes equation is still up for grabs. Fermion systems scale exponentially in the number of particles in a system. Lots of systems do not give us easy access to analytical or even numerical solutions we can be sure are correct."><meta itemprop=datePublished content="2025-01-31T15:15:24+01:00"><meta itemprop=dateModified content="2025-01-31T15:15:24+01:00"><meta itemprop=wordCount content="1555"><meta property="og:url" content="https://konradha.com/posts/part1-exponential-integrators/"><meta property="og:site_name" content="א"><meta property="og:title" content="Exponential Integrators for PDEs"><meta property="og:description" content="Disclaimer: Lots of sources are missing here. Will be added in the future.
This is the first one of a sequence of posts during which we’ll work through efficiently writing a simple finite differences simulation. We’ll touch on some physics, some numerical methods, some C++, some CUDA. Eventually we’ll see some pretty animations.
Integrable Systems Understanding nature is hard. For instance, the Millenium prize to find analytical solutions to the Navier-Stokes equation is still up for grabs. Fermion systems scale exponentially in the number of particles in a system. Lots of systems do not give us easy access to analytical or even numerical solutions we can be sure are correct."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-31T15:15:24+01:00"><meta property="article:modified_time" content="2025-01-31T15:15:24+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Exponential Integrators for PDEs"><meta name=twitter:description content="Disclaimer: Lots of sources are missing here. Will be added in the future.
This is the first one of a sequence of posts during which we’ll work through efficiently writing a simple finite differences simulation. We’ll touch on some physics, some numerical methods, some C++, some CUDA. Eventually we’ll see some pretty animations.
Integrable Systems Understanding nature is hard. For instance, the Millenium prize to find analytical solutions to the Navier-Stokes equation is still up for grabs. Fermion systems scale exponentially in the number of particles in a system. Lots of systems do not give us easy access to analytical or even numerical solutions we can be sure are correct."><link rel=canonical href=https://konradha.com/posts/part1-exponential-integrators/></head><link rel=stylesheet href=/css/fix.css><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://konradha.com/>א</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#f8f5d7".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100vh-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">Exponential Integrators for PDEs</h1><div class="text-xs antialiased opacity-60"><time>Jan 31, 2025</time></div></header><section><p><em>Disclaimer: Lots of sources are missing here. Will be added in the future.</em></p><p>This is the first one of a sequence of posts during which we&rsquo;ll work through
efficiently writing a simple finite differences simulation. We&rsquo;ll touch on some physics,
some numerical methods, some C++, some CUDA. Eventually we&rsquo;ll see some pretty animations.</p><h4 id=integrable-systems>Integrable Systems</h4><p>Understanding nature is hard. For instance, the Millenium prize to find analytical solutions
to the Navier-Stokes equation is still up for grabs. Fermion systems scale exponentially
in the number of particles in a system. Lots of systems do not give us easy access to
analytical or even numerical solutions we can be sure are correct.</p><p>However, nature leaves breadcrumbs. We can model detached phenomena using systems we
understand well. Predicting a tsunami trajectories, modelling the trajectory of rogue waves, optical
data transmission in glass fibre, or magnetic confinement &ndash; we can model all of these
using integrable systems that we can sum up as <code>Nonlinear Wave Equations</code>.</p><p>What makes these equations special is that they&rsquo;re so-called <a href=https://en.wikipedia.org/wiki/Integrable_system>integrable
systems</a>. It&rsquo;s a deep field with connections
from dynamical systems to algebraic geometry &ndash; we&rsquo;ll not go into too much detail here.</p><p>A few notions are, however, interesting to see.
Integrable systems consume an infinite number of observables. Ie. in the context of numerical
methods, we can check the behavior of different such quantities. We thus have easy access to
proxies letting us understand the behavior of our methods in a diverse set of ways.
We can, for instance, find two quantities emerging from a simple energy conservation
consideration. Without going to deep theory-wise, let&rsquo;s look at the sine-Gordon equation</p><p>$$u_{tt} = c(x, y) \left(u_{xx} + u_{yy}\right) - m(x, y) \sin(u)$$</p><p>with corresponding Hamiltonian (let&rsquo;s for the sake of argument forget about the focus/nonlinear $c, m$ terms)</p><p>$$H = \int \left(\frac{1}{2} \left(|\nabla u|^2 + |u_t|^2\right) + (1 - \cos(u)) \right) d\Omega $$</p><p>With a corresponding real domain $\Omega \subseteq \mathbf{R}^{k}$ which we&rsquo;re integrating over.
Using calculus of variations we can derive two fields which should yield identical parts
of the Hamiltonian: The energy density and the energy flux. The interested reader can find the expressions
of both very quickly, taking the time derivative of the Hamiltonian density and observing the arising
expression for $u_{tt}$.</p><p>From this we can observe at different time steps what our numerical method might get wrong, where it
might unnecessarily oscillate, what non-smooth features of a given system it might not be able to capture.
It&rsquo;s a solid tool to debug numerical methods.</p><p>Apart from this very practical consideration, integrable systems give us access to much more.
Let&rsquo;s look at <a href=https://en.wikipedia.org/wiki/Lax_pair>Lax pairs</a>: Without going into too much detail,
reformulating an integrable system in terms of its correspodning Lax pair lets us understand the
underlying <em>structure</em> of a given system. We can get access to different classes of analytical
solutions, their geometries, their long-term behavior. A huge accelerant for progress in the field
of integrable systems has been the Inverse Scattering Transform, one of the main methods to
construct analytical solutions from Lax pairs. It&rsquo;s been developed further recently to yield
<a href=https://arxiv.org/abs/2312.11780>more advanced numerical methods</a>.</p><p>In the interest of not wasting too much time on mathematical details, we&rsquo;ll cut the exploration here. See the linked
references if you&rsquo;re interested in the physics and the actual development of the related methods :)</p><h4 id=structure-preserving-integrators>Structure-preserving integrators</h4><p>The integrable equation we&rsquo;ll be treating are evolution equations. Hence, we&rsquo;ll have to think deeply about
how to integrate every given system for a time step $\tau$.</p><p>What are good <em>integrators</em> for our <em>integrable systems</em>?</p><p>For systems evolving under $u_{tt}$, nature has given us a great method, given we don&rsquo;t have difficult spectral
or integral operators that we need to take care of. One can show that the Stormer-Verlet update step is
symplectic. It&rsquo;s explicit and <em>preserves structure</em>. Geometric and integrability properties are respected in this
setting. For our sine-Gordon equation we can quickly write it down</p><p>$$u_{n+1} = 2 u_n - u_{n-1} + \tau^2 \left( c(x, y) \Delta u_{n} - m(x, y) \sin(u_{n}) \right)$$</p><p>Assuming we integrate over $n_t$ time steps in $[0,T]$ with $\tau = \frac{T}{n_t}$.</p><p>But that&rsquo;s not an exponential integrator. Honoring the promise of this article&rsquo;s title,
there are more, maybe better integrators. Assume a general time-dependent problem formulated as</p><p>$$u_{tt} + A u = g\left(u\right)$$</p><p>where $A$ is a linear operator and $g$ is a constant inhomogeneity, we can rely on <a href=https://ludwiggauckler.github.io/habil-web.pdf>Hairer, Lubich, Grimm&rsquo;s and
friend&rsquo;s work</a>[PDF]. It stems from considerations of the <a href=https://en.wikipedia.org/wiki/Variation_of_parameters>variation of constants
formula</a>, where we can express the update &ndash; given
$L$ is a sufficiently stiff operator such that we need such an involved integrator &ndash; as follows</p><p>$$ u_{n+1} - 2 \cos \left(\tau \Omega \right) u_n + u_{n-1} = \tau^2 \psi^2 \left(\frac{\tau}{2} \Omega \right)
g\left( \phi \left(\tau \Omega \right) u_{n} \right)$$</p><p>where $\psi$ and $\phi$ are appropriately chosen <em>filter functions</em> and $\Omega^2= A$.</p><p>Okay, great, we have a nice exponential integrator for systems involving $u_{tt}$. And <a href=TODO>we can even show that it
performs really well compared to Stormer-Verlet</a> (under the right constraints).</p><h5 id=what-if-our-model-does-not-evolve-in-_tt-though>What if our model does NOT evolve in $_{tt}$, though?</h5><p>For instance, the Alfvén or NLS equations look something like $i u_t = &mldr;$. For completeness, the NLSE looks like</p><p>$$ i u_t + (u_{xx} + u_{yy}) + |u|^{2} u = 0 $$</p><p>Here, the solution that preserves
structure (is symplectic) needs to look differently. We can make use of the fundamental solution to the NLS which
looks like</p><p>$$u(\tau) = \exp\left(-i \tau H\right) u_0$$</p><p>which we see is already problematic as for us, $H = \Delta + |u|^2$. How would we evaluate this function?
The <a href=https://en.wikipedia.org/wiki/Baker%E2%80%93Campbell%E2%80%93Hausdorff_formula>BCH formula</a> already tells us
that we can&rsquo;t arbitrarily switch order of application of operators here. Not cool. What else is there? Well,
instead of trying to run $u(t + \tau) = \exp\left(-i \tau H\right) u(t)$, we could split our Hamiltonian into
$$H = L + N$$ in terms of linear and nonlinear operators. That way, we can define another <em>symplectic</em> integrator</p><p>$$\exp(-i\tau H) = \exp\left(N(-i\tau/2) \cdot L(-i\tau) \cdot N(-i\tau/2) \right) + \mathcal{O} \left(\tau^3\right)$$</p><p>In practice for the NLSE this looks like</p><p>$$u_{n+1} = \exp(-i \tau/2 N) \exp(-i \tau L) \exp(-i \tau/2 N) u_{n}$$</p><p>which is nice and all, but we still don&rsquo;t know what we&rsquo;re computing here.</p><h4 id=finite-differences>Finite differences</h4><p>We&rsquo;ve now investigated discretization in terms of time. Unfortunately, we need to represent our systems on a machine
that has finite precision and so we need to discretize in space as well. A great teacher of mine &ndash; a physicist &ndash;
told us to never employ finite differences to evolve the Schrödinger equation. He used the words &ldquo;brain-dead&rdquo; and
&ldquo;embarrassed&rdquo; in that context.</p><p>Anyway. We&rsquo;ll look at finite differences for our 2 + 1 dimensional system now. It&rsquo;s a method simple enough for us
to just neglect meshing and other considerations. It&rsquo;s one part of the discretization we can easily[*] exchange.</p><p>For finite differences we could apply a stencil. We can nicely describe different physical boundary conditions
in finite differences as well. People love to use their spectral methods, but they&rsquo;re not entirely physical in
that very few natural domain really show us this highly regular periodic behavior. Hm.</p><p>Finite differences matrices for a square domain are computed quickly. They have nice structure one can exploit.
More on that later.</p><p>Looking at our integrators for the SGE and the NLSE, we can quickly observe that the linear operator L is
what we need to discretize here.</p><p>The usual formulation is the first-order 5-point stencil</p><p>$$u^n_{i, j} = \frac{u^n_{i+1, j} - 2 u^n_{i, j} + u^n_{i-1, j}}{h_x^2} + \frac{u^n_{i, j+1} - 2 u^n_{i, j} + u^n_{i, j-1}}{h_y^2}$$</p><p>which we can also very concisely express as a Numpy &ldquo;kernel&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>u_xx_yy</span>(buf, a, dx, dy):
</span></span><span style=display:flex><span>    uxx_yy <span style=color:#f92672>=</span> buf
</span></span><span style=display:flex><span>    uxx_yy[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>        (a[<span style=color:#ae81ff>2</span>:, <span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> a[:<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> a[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) <span style=color:#f92672>/</span> (dx <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        (a[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>:] <span style=color:#f92672>+</span> a[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, :<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> a[<span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) <span style=color:#f92672>/</span> (dy <span style=color:#f92672>**</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> uxx_yy
</span></span></code></pre></div><p>Let&rsquo;s assume, for simplicity that our domain is $[-L_x, L_x]^2$ discretized with $n_x$, $n_y$ points.
For no-flux, homogeneous von-Neumann boundary conditions: $\frac{\partial u}{\partial \vec{n}} = 0$.
Discretizing along the Cartesian x-y axis as $(n_x, n_y)$ yields a sparse matrix which is triadiagonal with
2 bands at the diagonals $+/- n_x$.</p><h4 id=what-could-be-done>What could be done</h4><p>This is all very nice with some very simple building blocks. Of course, to get predictably good behavior for our
numerical methods we&rsquo;d like to employ finite elements or &ndash; even better &ndash; finite volume methods. The latter give
us access to actual flow and energy control on a granular level impossible when employing finite differences. It
however also implies lots of work considering building up the related sparse systems. We&rsquo;ll leave that for another
day. We also haven&rsquo;t touched on spectral methods and any of the deeper details of IST, integrable systems
and solving Riemann-Hilbert Problems. This we&rsquo;ll leave for another day as well.</p><h4 id=next-time>Next time</h4><p>We&rsquo;ve looked at some fairly basic methods and gained a preliminary understanding of integrable systems. In the next part
we&rsquo;ll be exploring some of the technical difficulties we&rsquo;ll have to come up with solutions for before implemementing
any advanced kernel-based methods. For instance, how do we build sparse matrices we can use further down the line?
How do we compute matrix functions, even moreso trigonometric matrix functions?</p></section><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://konradha.com/posts/part2-computing-matrix-functions/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Computing Matrix Functions</span></a>
<a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href=https://konradha.com/posts/iterated-csps/><span>T=0 in a glassy system = ?</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>&copy; 2025
<a class=link href=https://konradha.com/>א</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>