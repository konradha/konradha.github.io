<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on א</title><link>https://konradha.github.io/posts/</link><description>Recent content in Posts on א</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 20 Nov 2023 19:51:29 +0100</lastBuildDate><atom:link href="https://konradha.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>A lattice</title><link>https://konradha.github.io/posts/lattice/</link><pubDate>Mon, 20 Nov 2023 19:51:29 +0100</pubDate><guid>https://konradha.github.io/posts/lattice/</guid><description>Exploring Monte Carlo simulations of certain physical systems. There are two types of MC steps here, one being the cause for the flickering of the background grey scale.
I like the moving colors.</description></item><item><title>Current reading list on compilers + PL</title><link>https://konradha.github.io/posts/hpc-articles/</link><pubDate>Fri, 29 Sep 2023 00:02:43 +0200</pubDate><guid>https://konradha.github.io/posts/hpc-articles/</guid><description>Some articles I&amp;rsquo;m currently reading (WIP):
physicists and FORTRAN C++ HPC + FORTRAN about OCaml OCaml performance</description></item><item><title>Solving PDEs using ✨Machine Learning✨</title><link>https://konradha.github.io/posts/pinns/</link><pubDate>Wed, 07 Jun 2023 18:57:35 +0200</pubDate><guid>https://konradha.github.io/posts/pinns/</guid><description>At university some of us choose to learn how to solve PDEs numerically. Usually, you pass years learning about approximation theory, test functions, finite elements, C++, functional analysis, visualization libraries, parallelization. Finally, you put it together to solve heat or wave equations. Then, when you&amp;rsquo;re more of a practitioner in industry, you fall back to using Ansys. In 2023 however, we can just take our good ol&amp;rsquo; reliable Pytorch and have Adam walk the space that minimizes the residuals we define for a given PDE.</description></item><item><title>Minimum weight error correction in the surface code</title><link>https://konradha.github.io/posts/surface_code_note/</link><pubDate>Fri, 12 May 2023 15:38:47 +0200</pubDate><guid>https://konradha.github.io/posts/surface_code_note/</guid><description>I&amp;rsquo;ve gotten a little confused by different terminologies and complexities involved in correcting errors in the surface code so I&amp;rsquo;ve rewritten the MWPM-involving algorithm to better understand it. A good reference (with fast accompanying library) is 1.
Picture the surface code. Consider the following procedure to estimate and correct the error in a given word.
Generate the parity check matrix H for one of the operators (X-type or Z-type) over mod 2.</description></item><item><title>Hello World</title><link>https://konradha.github.io/posts/hello-world/</link><pubDate>Sun, 09 Oct 2022 15:47:02 +0200</pubDate><guid>https://konradha.github.io/posts/hello-world/</guid><description/></item></channel></rss>